<!-- vim: set ft=markdown.pandoc: -->

- [.] parsing
  - [.] packrat parser
    - [x] parser
    - [x] combinators
    - [x] text position
    - [ ] tests
    - [x] Deriv datatype not typeclass **NO NEED**: memoization on instance implementor
    - [ ] bonus: QQ TemplateHaskell ()
  - [.] AST building
    - [x] smart constructors
- [.] evaluation
  - [x] AST error handling
  - [x] LISP -> Haskell types
  - [.] lambda application
  - [.] env management
  - [ ] tests
  - [x] rewrite rules
    - [x] `(define (func p) expr)` -> `(define func (lambda (p) (expr)))`
    - [x] `(let ((a 1) (b 2)) (+ a b))` -> `((lambda (a b) (+ a b)) 1 2)`
    - [x] `'(a b c)` -> `(quote (a b c))`
      - [x] what about `'"str"`/`'1`?: `quote` everything, non-(atom|list)s get autoquoted
    - [x] `(a . b . c)` -> `(a b c)`
      - [x] `(a . (b . c))` -> `(a b . c)`
- [.] general UX
  - [x] `Pos` in syntax errors
  - [ ] `Pos` in runtime errors
    - [ ] thread `Pos` into AST? `Cofree`?
  - [x] REPL
  - [x] `stdlib.scm`
